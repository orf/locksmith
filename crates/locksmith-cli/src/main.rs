use anyhow::Context;
use clap::Parser;
use clio::Output;
use locksmith::QueryOracle;
use std::io::stderr;
use std::path::PathBuf;
use testcontainers_modules::postgres::Postgres;
use testcontainers_modules::testcontainers::{runners::AsyncRunner, ContainerAsync, ImageExt};
use tracing::info;
use tracing::level_filters::LevelFilter;
use tracing_subscriber::{fmt, prelude::*, EnvFilter};

pub const DEFAULT_POSTGRES_TAG: &str = "15-alpine";

#[derive(Debug, clap::Parser)]
#[clap(version)]
struct Args {
    /// The path to a file containing the initial database schema for the test. This can be
    /// in a plaintext SQL format or a binary format generated by `pg_dump`.
    schema_file: PathBuf,
    /// The SQL query to inspect
    query: String,

    /// The tag of the Postgres container to start
    #[clap(short, long, default_value=DEFAULT_POSTGRES_TAG)]
    tag: String,

    /// The output file to write the inspection results to. If not provided, the results will be
    /// written to stdout.
    #[clap(long, short, value_parser, default_value = "-")]
    output: Output,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    tracing_subscriber::registry()
        .with(fmt::layer().with_writer(stderr))
        .with(
            EnvFilter::builder()
                .with_default_directive(LevelFilter::INFO.into())
                .from_env_lossy(),
        )
        .init();

    let args = Args::parse();
    let schema = std::fs::read(&args.schema_file)
        .with_context(|| format!("Reading schema file from {:?}", args.schema_file))?;
    let (_container, dsn) = start_postgres(schema, args.tag)
        .await
        .context("Creating Postgres container")?;

    let mut oracle = QueryOracle::new(dsn);
    let inspected_statement = oracle.inspect_statement(&args.query).await?;

    info!(
        added = inspected_statement.added_objects.len(),
        removed = inspected_statement.removed_objects.len(),
        locks = inspected_statement.locks.len(),
        rewrites = inspected_statement.rewrites.len(),
        "Inspected statement"
    );
    serde_json::to_writer_pretty(args.output, &inspected_statement)?;
    Ok(())
}

async fn start_postgres(
    schema: Vec<u8>,
    tag: impl AsRef<str>,
) -> anyhow::Result<(ContainerAsync<Postgres>, String)> {
    const USER: &str = "user";
    const PASSWORD: &str = "password";

    let tag = tag.as_ref();
    info!(tag, "Starting Postgres container");
    let container = Postgres::default()
        .with_init_sql(schema)
        .with_user(USER)
        .with_password(PASSWORD)
        .with_tag(tag)
        .start()
        .await
        .with_context(|| format!("Starting Postgres container with tag {}", tag))?;
    let id = container.id();
    let host_ip = container
        .get_host()
        .await
        .with_context(|| format!("Retrieving IP for container {id}"))?;
    let host_port = container
        .get_host_port_ipv4(5432)
        .await
        .with_context(|| format!("Retrieving mapped port 5432 for container {id}"))?;
    let dsn = format!("postgresql://{USER}:{PASSWORD}@{host_ip}:{host_port}/postgres");
    Ok((container, dsn))
}
