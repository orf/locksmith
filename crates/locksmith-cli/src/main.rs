use anyhow::Context;
use askama::Template;
use clap::Parser;
use clio::Output;
use itertools::Itertools;
use locksmith::{DBObject, QueryOracle, TableLock};
use std::io::Write;
use std::io::stderr;
use std::path::PathBuf;
use testcontainers_modules::postgres::Postgres;
use testcontainers_modules::testcontainers::{ContainerAsync, ImageExt, runners::AsyncRunner};
use tracing::info;
use tracing::level_filters::LevelFilter;
use tracing_subscriber::{EnvFilter, fmt, prelude::*};

pub const DEFAULT_POSTGRES_TAG: &str = "15-alpine";

#[derive(Debug, clap::Parser)]
#[clap(version)]
struct Args {
    /// The path to a file containing the initial database schema for the test. This can be
    /// in a plaintext SQL format or a binary format generated by `pg_dump`.
    schema_file: PathBuf,
    /// The SQL query to inspect
    query: String,

    /// The tag of the Postgres container to start
    #[clap(short, long, env="POSTGRES_TAG", default_value=DEFAULT_POSTGRES_TAG)]
    tag: String,

    /// The output file to write the inspection results to. If not provided, the results will be
    /// written to stdout.
    #[clap(long, short, value_parser, default_value = "-")]
    output: Output,

    /// The output format
    #[clap(long, short, value_enum, default_value_t = OutputFormat::Json)]
    format: OutputFormat,
}

#[derive(Debug, Copy, Clone, clap::ValueEnum)]
enum OutputFormat {
    Json,
    Markdown,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    tracing_subscriber::registry()
        .with(fmt::layer().with_writer(stderr))
        .with(
            EnvFilter::builder()
                .with_default_directive(LevelFilter::INFO.into())
                .from_env_lossy(),
        )
        .init();

    let args = Args::parse();
    let schema = std::fs::read(&args.schema_file)
        .with_context(|| format!("Reading schema file from {:?}", args.schema_file))?;
    let (_container, dsn) = start_postgres(schema, args.tag)
        .await
        .context("Creating Postgres container")?;

    let mut oracle = QueryOracle::new(dsn);
    let inspected_statement = oracle.inspect_statement(&args.query).await?;

    info!(
        added = inspected_statement.added_objects.len(),
        removed = inspected_statement.removed_objects.len(),
        locks = inspected_statement.locks.len(),
        rewrites = inspected_statement.rewrites.len(),
        "Inspected statement"
    );
    let mut output = args.output;
    match args.format {
        OutputFormat::Json => {
            serde_json::to_writer_pretty(output, &inspected_statement)?;
        }
        OutputFormat::Markdown => {
            let comment = MarkdownComment {
                statement: args.query,
                added_objects: inspected_statement
                    .added_objects
                    .into_iter()
                    .sorted()
                    .collect(),
                removed_objects: inspected_statement
                    .removed_objects
                    .into_iter()
                    .sorted()
                    .collect(),
                locks: inspected_statement.locks.into_iter().sorted().collect(),
                rewrites: inspected_statement.rewrites.into_iter().sorted().collect(),
            };
            let rendered = comment.render()?;
            writeln!(output, "{}", rendered)?;
        }
    }
    Ok(())
}

async fn start_postgres(
    schema: Vec<u8>,
    tag: impl AsRef<str>,
) -> anyhow::Result<(ContainerAsync<Postgres>, String)> {
    const USER: &str = "user";
    const PASSWORD: &str = "password";

    let tag = tag.as_ref();
    info!(tag, "Starting Postgres container");
    let container = Postgres::default()
        .with_init_sql(schema)
        .with_user(USER)
        .with_password(PASSWORD)
        .with_tag(tag)
        .start()
        .await
        .with_context(|| format!("Starting Postgres container with tag {}", tag))?;
    let id = container.id();
    let host_ip = container
        .get_host()
        .await
        .with_context(|| format!("Retrieving IP for container {id}"))?;
    let host_port = container
        .get_host_port_ipv4(5432)
        .await
        .with_context(|| format!("Retrieving mapped port 5432 for container {id}"))?;
    let dsn = format!("postgresql://{USER}:{PASSWORD}@{host_ip}:{host_port}/postgres");
    Ok((container, dsn))
}

#[derive(Template)]
#[template(path = "comment.md.jinja2")]
struct MarkdownComment {
    statement: String,
    added_objects: Vec<DBObject>,
    removed_objects: Vec<DBObject>,
    locks: Vec<TableLock>,
    rewrites: Vec<DBObject>,
}
